"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addBuildEntryPoints = exports.getDevEntryPoints = exports.getEntryFilesMapping = void 0;
const process_1 = require("process");
const path_1 = require("path");
const utils_1 = require("./utils");
const node_path_1 = __importDefault(require("node:path"));
const getDevEntryPoints = (config, viteDevServerUrl) => {
    const entryPoints = {};
    for (const [entryName, { entryPath, entryType }] of Object.entries(parseInput(config))) {
        entryPoints[entryName] = {
            [entryType]: [`${viteDevServerUrl}${config.base}${entryPath}`],
        };
    }
    return entryPoints;
};
exports.getDevEntryPoints = getDevEntryPoints;
const addBuildEntryPoints = (options, config, bundle, entryPoints) => {
    function getFileName(chunk) {
        if (chunk.type === 'asset') {
            return chunk.name;
        }
        else if (chunk.type === 'chunk') {
            if (chunk.facadeModuleId) {
                let name = (0, utils_1.normalizePath)(node_path_1.default.relative(config.root, chunk.facadeModuleId));
                if (options.format === 'system' && !chunk.name.includes('-legacy')) {
                    name = (0, utils_1.getLegacyName)(name);
                }
                return name.replace(/\0/g, '');
            }
            else {
                return chunk.fileName;
            }
        }
    }
    let name2exportName = {};
    for (let chunkName in bundle) {
        name2exportName[getFileName(bundle[chunkName])] = chunkName;
    }
    let entryFiles = parseInput(config);
    for (const [entryName, entry] of Object.entries(entryFiles)) {
        let exportPath = name2exportName[entry.entryPath];
        let fileInfos = bundle[exportPath];
        let isLegacy = false;
        if (!fileInfos) {
            let legacyEntryPath = (0, utils_1.getLegacyName)(entry.entryPath);
            exportPath = name2exportName[legacyEntryPath];
            fileInfos = bundle[exportPath];
            if (!fileInfos) {
                throw new Error(`Unable to find ${exportPath}`);
            }
            isLegacy = true;
        }
        let finalEntryName = isLegacy ? `${entryName}-legacy` : entryName;
        let legacyEntryPoint = typeof entryPoints[`${finalEntryName}-legacy`] !== "undefined" ? `${finalEntryName}-legacy` : false;
        entryPoints[finalEntryName] = resolveEntrypoint(fileInfos, bundle, config, legacyEntryPoint, true);
    }
    if (name2exportName['vite/legacy-polyfills-legacy']) {
        let fileInfos = bundle[name2exportName['vite/legacy-polyfills-legacy']];
        entryPoints['polyfills-legacy'] = resolveEntrypoint(fileInfos, bundle, config, false, true);
    }
    return entryPoints;
};
exports.addBuildEntryPoints = addBuildEntryPoints;
const resolveEntrypoint = (fileInfos, bundle, config, legacyEntryPoint, isCSSOrJsEntry) => {
    const js = [];
    const css = [];
    const preload = [];
    if (fileInfos.imports) {
        for (const importEntryName of fileInfos.imports) {
            let importFileInfos = bundle[importEntryName];
            if (!importFileInfos) {
                throw new Error(`Unable to find ${importEntryName}`);
            }
            const { css: importCss, preload: importPreload } = resolveEntrypoint(importFileInfos, bundle, config, false, false);
            for (const dependency of importCss) {
                if (css.indexOf(dependency) === -1) {
                    css.push(dependency);
                }
            }
            for (const dependency of importPreload) {
                if (preload.indexOf(dependency) === -1) {
                    preload.push(dependency);
                }
            }
        }
    }
    let filePath = `${config.base}${fileInfos.fileName}`;
    if (isCSSOrJsEntry) {
        if (fileInfos.isEntry) {
            // it is a JS file
            js.push(filePath);
        }
        else {
            css.push(filePath);
        }
    }
    else if (preload.indexOf(filePath) === -1) {
        preload.push(filePath);
    }
    if (fileInfos.viteMetadata?.importedCss.size) {
        fileInfos.viteMetadata.importedCss.forEach(cssFilePath => {
            css.push(`${config.base}${cssFilePath}`);
        });
    }
    return { js, css, preload, legacy: legacyEntryPoint };
};
const parseInput = (config) => {
    const inputParsed = {};
    // let isLegacy = (options.format === 'system' && bundle[chunkName].name.includes('-legacy'));
    for (const [entryName, entryPath] of Object.entries(config.build.rollupOptions.input)) {
        const entryAbsolutePath = (0, utils_1.normalizePath)((0, path_1.resolve)((0, process_1.cwd)(), entryPath));
        if (entryAbsolutePath.indexOf(config.root) !== 0) {
            console.error("Entry points must be inside Vite root directory");
            process.exit(1);
        }
        const extension = (0, path_1.extname)(entryPath);
        const entryType = [".css", ".scss", ".sass", ".less", ".styl", ".stylus", ".postcss"].indexOf(extension) !== -1 ? "css" : "js";
        const entryRelativePath = entryAbsolutePath.substring(config.root.length + 1);
        inputParsed[entryName] = {
            entryType,
            entryPath: entryRelativePath,
        };
    }
    return inputParsed;
};
const getEntryFilesMapping = (config) => {
    const inputParsed = {};
    // let isLegacy = (options.format === 'system' && bundle[chunkName].name.includes('-legacy'));
    for (const [entryName, entryPath] of Object.entries(config.build.rollupOptions.input)) {
        const entryAbsolutePath = (0, utils_1.normalizePath)((0, path_1.resolve)((0, process_1.cwd)(), entryPath));
        if (entryAbsolutePath.indexOf(config.root) !== 0) {
            console.error("Entry points must be inside Vite root directory");
            process.exit(1);
        }
        const entryRelativePath = entryAbsolutePath.substring(config.root.length + 1);
        inputParsed[entryName] = entryRelativePath;
    }
    return inputParsed;
};
exports.getEntryFilesMapping = getEntryFilesMapping;
//# sourceMappingURL=configResolver.js.map